/**
 * Autogenerated by Thrift Compiler (0.9.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "TCLIService_types.h"

#include <algorithm>

namespace apache { namespace hive { namespace service { namespace cli { namespace thrift {

int _kTProtocolVersionValues[] = {
  TProtocolVersion::HIVE_CLI_SERVICE_PROTOCOL_V1
};
const char* _kTProtocolVersionNames[] = {
  "HIVE_CLI_SERVICE_PROTOCOL_V1"
};
const std::map<int, const char*> _TProtocolVersion_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(1, _kTProtocolVersionValues, _kTProtocolVersionNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTTypeIdValues[] = {
  TTypeId::BOOLEAN_TYPE,
  TTypeId::TINYINT_TYPE,
  TTypeId::SMALLINT_TYPE,
  TTypeId::INT_TYPE,
  TTypeId::BIGINT_TYPE,
  TTypeId::FLOAT_TYPE,
  TTypeId::DOUBLE_TYPE,
  TTypeId::STRING_TYPE,
  TTypeId::TIMESTAMP_TYPE,
  TTypeId::BINARY_TYPE,
  TTypeId::ARRAY_TYPE,
  TTypeId::MAP_TYPE,
  TTypeId::STRUCT_TYPE,
  TTypeId::UNION_TYPE,
  TTypeId::USER_DEFINED_TYPE,
  TTypeId::DECIMAL_TYPE,
  TTypeId::VOID_TYPE
};
const char* _kTTypeIdNames[] = {
  "BOOLEAN_TYPE",
  "TINYINT_TYPE",
  "SMALLINT_TYPE",
  "INT_TYPE",
  "BIGINT_TYPE",
  "FLOAT_TYPE",
  "DOUBLE_TYPE",
  "STRING_TYPE",
  "TIMESTAMP_TYPE",
  "BINARY_TYPE",
  "ARRAY_TYPE",
  "MAP_TYPE",
  "STRUCT_TYPE",
  "UNION_TYPE",
  "USER_DEFINED_TYPE",
  "DECIMAL_TYPE",
  "VOID_TYPE"
};
const std::map<int, const char*> _TTypeId_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(17, _kTTypeIdValues, _kTTypeIdNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTStatusCodeValues[] = {
  TStatusCode::SUCCESS_STATUS,
  TStatusCode::SUCCESS_WITH_INFO_STATUS,
  TStatusCode::STILL_EXECUTING_STATUS,
  TStatusCode::ERROR_STATUS,
  TStatusCode::INVALID_HANDLE_STATUS
};
const char* _kTStatusCodeNames[] = {
  "SUCCESS_STATUS",
  "SUCCESS_WITH_INFO_STATUS",
  "STILL_EXECUTING_STATUS",
  "ERROR_STATUS",
  "INVALID_HANDLE_STATUS"
};
const std::map<int, const char*> _TStatusCode_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kTStatusCodeValues, _kTStatusCodeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTOperationStateValues[] = {
  TOperationState::INITIALIZED_STATE,
  TOperationState::RUNNING_STATE,
  TOperationState::FINISHED_STATE,
  TOperationState::CANCELED_STATE,
  TOperationState::CLOSED_STATE,
  TOperationState::ERROR_STATE,
  TOperationState::UKNOWN_STATE
};
const char* _kTOperationStateNames[] = {
  "INITIALIZED_STATE",
  "RUNNING_STATE",
  "FINISHED_STATE",
  "CANCELED_STATE",
  "CLOSED_STATE",
  "ERROR_STATE",
  "UKNOWN_STATE"
};
const std::map<int, const char*> _TOperationState_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(7, _kTOperationStateValues, _kTOperationStateNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTOperationTypeValues[] = {
  TOperationType::EXECUTE_STATEMENT,
  TOperationType::GET_TYPE_INFO,
  TOperationType::GET_CATALOGS,
  TOperationType::GET_SCHEMAS,
  TOperationType::GET_TABLES,
  TOperationType::GET_TABLE_TYPES,
  TOperationType::GET_COLUMNS,
  TOperationType::GET_FUNCTIONS,
  TOperationType::UNKNOWN
};
const char* _kTOperationTypeNames[] = {
  "EXECUTE_STATEMENT",
  "GET_TYPE_INFO",
  "GET_CATALOGS",
  "GET_SCHEMAS",
  "GET_TABLES",
  "GET_TABLE_TYPES",
  "GET_COLUMNS",
  "GET_FUNCTIONS",
  "UNKNOWN"
};
const std::map<int, const char*> _TOperationType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(9, _kTOperationTypeValues, _kTOperationTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTGetInfoTypeValues[] = {
  TGetInfoType::CLI_MAX_DRIVER_CONNECTIONS,
  TGetInfoType::CLI_MAX_CONCURRENT_ACTIVITIES,
  TGetInfoType::CLI_DATA_SOURCE_NAME,
  TGetInfoType::CLI_FETCH_DIRECTION,
  TGetInfoType::CLI_SERVER_NAME,
  TGetInfoType::CLI_SEARCH_PATTERN_ESCAPE,
  TGetInfoType::CLI_DBMS_NAME,
  TGetInfoType::CLI_DBMS_VER,
  TGetInfoType::CLI_ACCESSIBLE_TABLES,
  TGetInfoType::CLI_ACCESSIBLE_PROCEDURES,
  TGetInfoType::CLI_CURSOR_COMMIT_BEHAVIOR,
  TGetInfoType::CLI_DATA_SOURCE_READ_ONLY,
  TGetInfoType::CLI_DEFAULT_TXN_ISOLATION,
  TGetInfoType::CLI_IDENTIFIER_CASE,
  TGetInfoType::CLI_IDENTIFIER_QUOTE_CHAR,
  TGetInfoType::CLI_MAX_COLUMN_NAME_LEN,
  TGetInfoType::CLI_MAX_CURSOR_NAME_LEN,
  TGetInfoType::CLI_MAX_SCHEMA_NAME_LEN,
  TGetInfoType::CLI_MAX_CATALOG_NAME_LEN,
  TGetInfoType::CLI_MAX_TABLE_NAME_LEN,
  TGetInfoType::CLI_SCROLL_CONCURRENCY,
  TGetInfoType::CLI_TXN_CAPABLE,
  TGetInfoType::CLI_USER_NAME,
  TGetInfoType::CLI_TXN_ISOLATION_OPTION,
  TGetInfoType::CLI_INTEGRITY,
  TGetInfoType::CLI_GETDATA_EXTENSIONS,
  TGetInfoType::CLI_NULL_COLLATION,
  TGetInfoType::CLI_ALTER_TABLE,
  TGetInfoType::CLI_ORDER_BY_COLUMNS_IN_SELECT,
  TGetInfoType::CLI_SPECIAL_CHARACTERS,
  TGetInfoType::CLI_MAX_COLUMNS_IN_GROUP_BY,
  TGetInfoType::CLI_MAX_COLUMNS_IN_INDEX,
  TGetInfoType::CLI_MAX_COLUMNS_IN_ORDER_BY,
  TGetInfoType::CLI_MAX_COLUMNS_IN_SELECT,
  TGetInfoType::CLI_MAX_COLUMNS_IN_TABLE,
  TGetInfoType::CLI_MAX_INDEX_SIZE,
  TGetInfoType::CLI_MAX_ROW_SIZE,
  TGetInfoType::CLI_MAX_STATEMENT_LEN,
  TGetInfoType::CLI_MAX_TABLES_IN_SELECT,
  TGetInfoType::CLI_MAX_USER_NAME_LEN,
  TGetInfoType::CLI_OJ_CAPABILITIES,
  TGetInfoType::CLI_XOPEN_CLI_YEAR,
  TGetInfoType::CLI_CURSOR_SENSITIVITY,
  TGetInfoType::CLI_DESCRIBE_PARAMETER,
  TGetInfoType::CLI_CATALOG_NAME,
  TGetInfoType::CLI_COLLATION_SEQ,
  TGetInfoType::CLI_MAX_IDENTIFIER_LEN
};
const char* _kTGetInfoTypeNames[] = {
  "CLI_MAX_DRIVER_CONNECTIONS",
  "CLI_MAX_CONCURRENT_ACTIVITIES",
  "CLI_DATA_SOURCE_NAME",
  "CLI_FETCH_DIRECTION",
  "CLI_SERVER_NAME",
  "CLI_SEARCH_PATTERN_ESCAPE",
  "CLI_DBMS_NAME",
  "CLI_DBMS_VER",
  "CLI_ACCESSIBLE_TABLES",
  "CLI_ACCESSIBLE_PROCEDURES",
  "CLI_CURSOR_COMMIT_BEHAVIOR",
  "CLI_DATA_SOURCE_READ_ONLY",
  "CLI_DEFAULT_TXN_ISOLATION",
  "CLI_IDENTIFIER_CASE",
  "CLI_IDENTIFIER_QUOTE_CHAR",
  "CLI_MAX_COLUMN_NAME_LEN",
  "CLI_MAX_CURSOR_NAME_LEN",
  "CLI_MAX_SCHEMA_NAME_LEN",
  "CLI_MAX_CATALOG_NAME_LEN",
  "CLI_MAX_TABLE_NAME_LEN",
  "CLI_SCROLL_CONCURRENCY",
  "CLI_TXN_CAPABLE",
  "CLI_USER_NAME",
  "CLI_TXN_ISOLATION_OPTION",
  "CLI_INTEGRITY",
  "CLI_GETDATA_EXTENSIONS",
  "CLI_NULL_COLLATION",
  "CLI_ALTER_TABLE",
  "CLI_ORDER_BY_COLUMNS_IN_SELECT",
  "CLI_SPECIAL_CHARACTERS",
  "CLI_MAX_COLUMNS_IN_GROUP_BY",
  "CLI_MAX_COLUMNS_IN_INDEX",
  "CLI_MAX_COLUMNS_IN_ORDER_BY",
  "CLI_MAX_COLUMNS_IN_SELECT",
  "CLI_MAX_COLUMNS_IN_TABLE",
  "CLI_MAX_INDEX_SIZE",
  "CLI_MAX_ROW_SIZE",
  "CLI_MAX_STATEMENT_LEN",
  "CLI_MAX_TABLES_IN_SELECT",
  "CLI_MAX_USER_NAME_LEN",
  "CLI_OJ_CAPABILITIES",
  "CLI_XOPEN_CLI_YEAR",
  "CLI_CURSOR_SENSITIVITY",
  "CLI_DESCRIBE_PARAMETER",
  "CLI_CATALOG_NAME",
  "CLI_COLLATION_SEQ",
  "CLI_MAX_IDENTIFIER_LEN"
};
const std::map<int, const char*> _TGetInfoType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(47, _kTGetInfoTypeValues, _kTGetInfoTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTFetchOrientationValues[] = {
  TFetchOrientation::FETCH_NEXT,
  TFetchOrientation::FETCH_PRIOR,
  TFetchOrientation::FETCH_RELATIVE,
  TFetchOrientation::FETCH_ABSOLUTE,
  TFetchOrientation::FETCH_FIRST,
  TFetchOrientation::FETCH_LAST
};
const char* _kTFetchOrientationNames[] = {
  "FETCH_NEXT",
  "FETCH_PRIOR",
  "FETCH_RELATIVE",
  "FETCH_ABSOLUTE",
  "FETCH_FIRST",
  "FETCH_LAST"
};
const std::map<int, const char*> _TFetchOrientation_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(6, _kTFetchOrientationValues, _kTFetchOrientationNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

const char* TPrimitiveTypeEntry::ascii_fingerprint = "8BBB3D0C3B370CB38F2D1340BB79F0AA";
const uint8_t TPrimitiveTypeEntry::binary_fingerprint[16] = {0x8B,0xBB,0x3D,0x0C,0x3B,0x37,0x0C,0xB3,0x8F,0x2D,0x13,0x40,0xBB,0x79,0xF0,0xAA};

uint32_t TPrimitiveTypeEntry::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_type = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast0;
          xfer += iprot->readI32(ecast0);
          this->type = (TTypeId::type)ecast0;
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TPrimitiveTypeEntry::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TPrimitiveTypeEntry");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TPrimitiveTypeEntry &a, TPrimitiveTypeEntry &b) {
  using ::std::swap;
  swap(a.type, b.type);
}

const char* TArrayTypeEntry::ascii_fingerprint = "E86CACEB22240450EDCBEFC3A83970E4";
const uint8_t TArrayTypeEntry::binary_fingerprint[16] = {0xE8,0x6C,0xAC,0xEB,0x22,0x24,0x04,0x50,0xED,0xCB,0xEF,0xC3,0xA8,0x39,0x70,0xE4};

uint32_t TArrayTypeEntry::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_objectTypePtr = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->objectTypePtr);
          isset_objectTypePtr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_objectTypePtr)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TArrayTypeEntry::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TArrayTypeEntry");

  xfer += oprot->writeFieldBegin("objectTypePtr", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->objectTypePtr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TArrayTypeEntry &a, TArrayTypeEntry &b) {
  using ::std::swap;
  swap(a.objectTypePtr, b.objectTypePtr);
}

const char* TMapTypeEntry::ascii_fingerprint = "989D1F1AE8D148D5E2119FFEC4BBBEE3";
const uint8_t TMapTypeEntry::binary_fingerprint[16] = {0x98,0x9D,0x1F,0x1A,0xE8,0xD1,0x48,0xD5,0xE2,0x11,0x9F,0xFE,0xC4,0xBB,0xBE,0xE3};

uint32_t TMapTypeEntry::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_keyTypePtr = false;
  bool isset_valueTypePtr = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->keyTypePtr);
          isset_keyTypePtr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->valueTypePtr);
          isset_valueTypePtr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_keyTypePtr)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_valueTypePtr)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TMapTypeEntry::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TMapTypeEntry");

  xfer += oprot->writeFieldBegin("keyTypePtr", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->keyTypePtr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("valueTypePtr", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->valueTypePtr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TMapTypeEntry &a, TMapTypeEntry &b) {
  using ::std::swap;
  swap(a.keyTypePtr, b.keyTypePtr);
  swap(a.valueTypePtr, b.valueTypePtr);
}

const char* TStructTypeEntry::ascii_fingerprint = "91F548CA159B4AB4291F5741AC161402";
const uint8_t TStructTypeEntry::binary_fingerprint[16] = {0x91,0xF5,0x48,0xCA,0x15,0x9B,0x4A,0xB4,0x29,0x1F,0x57,0x41,0xAC,0x16,0x14,0x02};

uint32_t TStructTypeEntry::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_nameToTypePtr = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->nameToTypePtr.clear();
            uint32_t _size1;
            ::apache::thrift::protocol::TType _ktype2;
            ::apache::thrift::protocol::TType _vtype3;
            xfer += iprot->readMapBegin(_ktype2, _vtype3, _size1);
            uint32_t _i5;
            for (_i5 = 0; _i5 < _size1; ++_i5)
            {
              std::string _key6;
              xfer += iprot->readString(_key6);
              TTypeEntryPtr& _val7 = this->nameToTypePtr[_key6];
              xfer += iprot->readI32(_val7);
            }
            xfer += iprot->readMapEnd();
          }
          isset_nameToTypePtr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_nameToTypePtr)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TStructTypeEntry::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TStructTypeEntry");

  xfer += oprot->writeFieldBegin("nameToTypePtr", ::apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->nameToTypePtr.size()));
    std::map<std::string, TTypeEntryPtr> ::const_iterator _iter8;
    for (_iter8 = this->nameToTypePtr.begin(); _iter8 != this->nameToTypePtr.end(); ++_iter8)
    {
      xfer += oprot->writeString(_iter8->first);
      xfer += oprot->writeI32(_iter8->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TStructTypeEntry &a, TStructTypeEntry &b) {
  using ::std::swap;
  swap(a.nameToTypePtr, b.nameToTypePtr);
}

const char* TUnionTypeEntry::ascii_fingerprint = "91F548CA159B4AB4291F5741AC161402";
const uint8_t TUnionTypeEntry::binary_fingerprint[16] = {0x91,0xF5,0x48,0xCA,0x15,0x9B,0x4A,0xB4,0x29,0x1F,0x57,0x41,0xAC,0x16,0x14,0x02};

uint32_t TUnionTypeEntry::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_nameToTypePtr = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->nameToTypePtr.clear();
            uint32_t _size9;
            ::apache::thrift::protocol::TType _ktype10;
            ::apache::thrift::protocol::TType _vtype11;
            xfer += iprot->readMapBegin(_ktype10, _vtype11, _size9);
            uint32_t _i13;
            for (_i13 = 0; _i13 < _size9; ++_i13)
            {
              std::string _key14;
              xfer += iprot->readString(_key14);
              TTypeEntryPtr& _val15 = this->nameToTypePtr[_key14];
              xfer += iprot->readI32(_val15);
            }
            xfer += iprot->readMapEnd();
          }
          isset_nameToTypePtr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_nameToTypePtr)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TUnionTypeEntry::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TUnionTypeEntry");

  xfer += oprot->writeFieldBegin("nameToTypePtr", ::apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->nameToTypePtr.size()));
    std::map<std::string, TTypeEntryPtr> ::const_iterator _iter16;
    for (_iter16 = this->nameToTypePtr.begin(); _iter16 != this->nameToTypePtr.end(); ++_iter16)
    {
      xfer += oprot->writeString(_iter16->first);
      xfer += oprot->writeI32(_iter16->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TUnionTypeEntry &a, TUnionTypeEntry &b) {
  using ::std::swap;
  swap(a.nameToTypePtr, b.nameToTypePtr);
}

const char* TUserDefinedTypeEntry::ascii_fingerprint = "EFB929595D312AC8F305D5A794CFEDA1";
const uint8_t TUserDefinedTypeEntry::binary_fingerprint[16] = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

uint32_t TUserDefinedTypeEntry::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_typeClassName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->typeClassName);
          isset_typeClassName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_typeClassName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TUserDefinedTypeEntry::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TUserDefinedTypeEntry");

  xfer += oprot->writeFieldBegin("typeClassName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->typeClassName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TUserDefinedTypeEntry &a, TUserDefinedTypeEntry &b) {
  using ::std::swap;
  swap(a.typeClassName, b.typeClassName);
}

const char* TTypeEntry::ascii_fingerprint = "0C3ACE4054603E2D37B8BFEBA79F4159";
const uint8_t TTypeEntry::binary_fingerprint[16] = {0x0C,0x3A,0xCE,0x40,0x54,0x60,0x3E,0x2D,0x37,0xB8,0xBF,0xEB,0xA7,0x9F,0x41,0x59};

uint32_t TTypeEntry::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->primitiveEntry.read(iprot);
          this->__isset.primitiveEntry = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->arrayEntry.read(iprot);
          this->__isset.arrayEntry = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->mapEntry.read(iprot);
          this->__isset.mapEntry = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->structEntry.read(iprot);
          this->__isset.structEntry = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->unionEntry.read(iprot);
          this->__isset.unionEntry = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userDefinedTypeEntry.read(iprot);
          this->__isset.userDefinedTypeEntry = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TTypeEntry::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TTypeEntry");

  xfer += oprot->writeFieldBegin("primitiveEntry", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->primitiveEntry.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("arrayEntry", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->arrayEntry.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mapEntry", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->mapEntry.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("structEntry", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->structEntry.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("unionEntry", ::apache::thrift::protocol::T_STRUCT, 5);
  xfer += this->unionEntry.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("userDefinedTypeEntry", ::apache::thrift::protocol::T_STRUCT, 6);
  xfer += this->userDefinedTypeEntry.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TTypeEntry &a, TTypeEntry &b) {
  using ::std::swap;
  swap(a.primitiveEntry, b.primitiveEntry);
  swap(a.arrayEntry, b.arrayEntry);
  swap(a.mapEntry, b.mapEntry);
  swap(a.structEntry, b.structEntry);
  swap(a.unionEntry, b.unionEntry);
  swap(a.userDefinedTypeEntry, b.userDefinedTypeEntry);
  swap(a.__isset, b.__isset);
}

const char* TTypeDesc::ascii_fingerprint = "60CA5B8BACFCD38D1D3EC1F0E3F1C36A";
const uint8_t TTypeDesc::binary_fingerprint[16] = {0x60,0xCA,0x5B,0x8B,0xAC,0xFC,0xD3,0x8D,0x1D,0x3E,0xC1,0xF0,0xE3,0xF1,0xC3,0x6A};

uint32_t TTypeDesc::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_types = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->types.clear();
            uint32_t _size17;
            ::apache::thrift::protocol::TType _etype20;
            xfer += iprot->readListBegin(_etype20, _size17);
            this->types.resize(_size17);
            uint32_t _i21;
            for (_i21 = 0; _i21 < _size17; ++_i21)
            {
              xfer += this->types[_i21].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_types = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_types)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TTypeDesc::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TTypeDesc");

  xfer += oprot->writeFieldBegin("types", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->types.size()));
    std::vector<TTypeEntry> ::const_iterator _iter22;
    for (_iter22 = this->types.begin(); _iter22 != this->types.end(); ++_iter22)
    {
      xfer += (*_iter22).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TTypeDesc &a, TTypeDesc &b) {
  using ::std::swap;
  swap(a.types, b.types);
}

const char* TColumnDesc::ascii_fingerprint = "0DF9A37B81B1EE73D35A0AC01F33A48D";
const uint8_t TColumnDesc::binary_fingerprint[16] = {0x0D,0xF9,0xA3,0x7B,0x81,0xB1,0xEE,0x73,0xD3,0x5A,0x0A,0xC0,0x1F,0x33,0xA4,0x8D};

uint32_t TColumnDesc::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_columnName = false;
  bool isset_typeDesc = false;
  bool isset_position = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->columnName);
          isset_columnName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->typeDesc.read(iprot);
          isset_typeDesc = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->position);
          isset_position = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->comment);
          this->__isset.comment = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_columnName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_typeDesc)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_position)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TColumnDesc::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TColumnDesc");

  xfer += oprot->writeFieldBegin("columnName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->columnName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("typeDesc", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->typeDesc.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("position", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->position);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.comment) {
    xfer += oprot->writeFieldBegin("comment", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->comment);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TColumnDesc &a, TColumnDesc &b) {
  using ::std::swap;
  swap(a.columnName, b.columnName);
  swap(a.typeDesc, b.typeDesc);
  swap(a.position, b.position);
  swap(a.comment, b.comment);
  swap(a.__isset, b.__isset);
}

const char* TTableSchema::ascii_fingerprint = "E67E789F1EF836E4B9FC922C788AFDC8";
const uint8_t TTableSchema::binary_fingerprint[16] = {0xE6,0x7E,0x78,0x9F,0x1E,0xF8,0x36,0xE4,0xB9,0xFC,0x92,0x2C,0x78,0x8A,0xFD,0xC8};

uint32_t TTableSchema::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_columns = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columns.clear();
            uint32_t _size23;
            ::apache::thrift::protocol::TType _etype26;
            xfer += iprot->readListBegin(_etype26, _size23);
            this->columns.resize(_size23);
            uint32_t _i27;
            for (_i27 = 0; _i27 < _size23; ++_i27)
            {
              xfer += this->columns[_i27].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_columns)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TTableSchema::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TTableSchema");

  xfer += oprot->writeFieldBegin("columns", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->columns.size()));
    std::vector<TColumnDesc> ::const_iterator _iter28;
    for (_iter28 = this->columns.begin(); _iter28 != this->columns.end(); ++_iter28)
    {
      xfer += (*_iter28).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TTableSchema &a, TTableSchema &b) {
  using ::std::swap;
  swap(a.columns, b.columns);
}

const char* TBoolValue::ascii_fingerprint = "F9058324D96DB7F974D8ACDC01C54219";
const uint8_t TBoolValue::binary_fingerprint[16] = {0xF9,0x05,0x83,0x24,0xD9,0x6D,0xB7,0xF9,0x74,0xD8,0xAC,0xDC,0x01,0xC5,0x42,0x19};

uint32_t TBoolValue::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_values = false;
  bool isset_nulls = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->values.clear();
            uint32_t _size29;
            ::apache::thrift::protocol::TType _etype32;
            xfer += iprot->readListBegin(_etype32, _size29);
            this->values.resize(_size29);
            uint32_t _i33;
            for (_i33 = 0; _i33 < _size29; ++_i33)
            {
              xfer += iprot->readBool(this->values[_i33]);
            }
            xfer += iprot->readListEnd();
          }
          isset_values = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->nulls);
          isset_nulls = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_values)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_nulls)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TBoolValue::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TBoolValue");

  xfer += oprot->writeFieldBegin("values", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_BOOL, static_cast<uint32_t>(this->values.size()));
    std::vector<bool> ::const_iterator _iter34;
    for (_iter34 = this->values.begin(); _iter34 != this->values.end(); ++_iter34)
    {
      xfer += oprot->writeBool((*_iter34));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nulls", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->nulls);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TBoolValue &a, TBoolValue &b) {
  using ::std::swap;
  swap(a.values, b.values);
  swap(a.nulls, b.nulls);
}

const char* TByteValue::ascii_fingerprint = "1CB300106BAA463A70BB2A2395900F48";
const uint8_t TByteValue::binary_fingerprint[16] = {0x1C,0xB3,0x00,0x10,0x6B,0xAA,0x46,0x3A,0x70,0xBB,0x2A,0x23,0x95,0x90,0x0F,0x48};

uint32_t TByteValue::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_values = false;
  bool isset_nulls = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->values.clear();
            uint32_t _size35;
            ::apache::thrift::protocol::TType _etype38;
            xfer += iprot->readListBegin(_etype38, _size35);
            this->values.resize(_size35);
            uint32_t _i39;
            for (_i39 = 0; _i39 < _size35; ++_i39)
            {
              xfer += iprot->readByte(this->values[_i39]);
            }
            xfer += iprot->readListEnd();
          }
          isset_values = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->nulls);
          isset_nulls = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_values)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_nulls)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TByteValue::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TByteValue");

  xfer += oprot->writeFieldBegin("values", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_BYTE, static_cast<uint32_t>(this->values.size()));
    std::vector<int8_t> ::const_iterator _iter40;
    for (_iter40 = this->values.begin(); _iter40 != this->values.end(); ++_iter40)
    {
      xfer += oprot->writeByte((*_iter40));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nulls", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->nulls);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TByteValue &a, TByteValue &b) {
  using ::std::swap;
  swap(a.values, b.values);
  swap(a.nulls, b.nulls);
}

const char* TI16Value::ascii_fingerprint = "6574CDB1F121C8DB47FB257A3F104BDB";
const uint8_t TI16Value::binary_fingerprint[16] = {0x65,0x74,0xCD,0xB1,0xF1,0x21,0xC8,0xDB,0x47,0xFB,0x25,0x7A,0x3F,0x10,0x4B,0xDB};

uint32_t TI16Value::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_values = false;
  bool isset_nulls = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->values.clear();
            uint32_t _size41;
            ::apache::thrift::protocol::TType _etype44;
            xfer += iprot->readListBegin(_etype44, _size41);
            this->values.resize(_size41);
            uint32_t _i45;
            for (_i45 = 0; _i45 < _size41; ++_i45)
            {
              xfer += iprot->readI16(this->values[_i45]);
            }
            xfer += iprot->readListEnd();
          }
          isset_values = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->nulls);
          isset_nulls = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_values)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_nulls)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TI16Value::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TI16Value");

  xfer += oprot->writeFieldBegin("values", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I16, static_cast<uint32_t>(this->values.size()));
    std::vector<int16_t> ::const_iterator _iter46;
    for (_iter46 = this->values.begin(); _iter46 != this->values.end(); ++_iter46)
    {
      xfer += oprot->writeI16((*_iter46));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nulls", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->nulls);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TI16Value &a, TI16Value &b) {
  using ::std::swap;
  swap(a.values, b.values);
  swap(a.nulls, b.nulls);
}

const char* TI32Value::ascii_fingerprint = "CCCCE89C7E9DA10280F5663700677313";
const uint8_t TI32Value::binary_fingerprint[16] = {0xCC,0xCC,0xE8,0x9C,0x7E,0x9D,0xA1,0x02,0x80,0xF5,0x66,0x37,0x00,0x67,0x73,0x13};

uint32_t TI32Value::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_values = false;
  bool isset_nulls = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->values.clear();
            uint32_t _size47;
            ::apache::thrift::protocol::TType _etype50;
            xfer += iprot->readListBegin(_etype50, _size47);
            this->values.resize(_size47);
            uint32_t _i51;
            for (_i51 = 0; _i51 < _size47; ++_i51)
            {
              xfer += iprot->readI32(this->values[_i51]);
            }
            xfer += iprot->readListEnd();
          }
          isset_values = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->nulls);
          isset_nulls = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_values)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_nulls)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TI32Value::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TI32Value");

  xfer += oprot->writeFieldBegin("values", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->values.size()));
    std::vector<int32_t> ::const_iterator _iter52;
    for (_iter52 = this->values.begin(); _iter52 != this->values.end(); ++_iter52)
    {
      xfer += oprot->writeI32((*_iter52));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nulls", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->nulls);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TI32Value &a, TI32Value &b) {
  using ::std::swap;
  swap(a.values, b.values);
  swap(a.nulls, b.nulls);
}

const char* TI64Value::ascii_fingerprint = "925353917FC0AF87976A2338011F5A31";
const uint8_t TI64Value::binary_fingerprint[16] = {0x92,0x53,0x53,0x91,0x7F,0xC0,0xAF,0x87,0x97,0x6A,0x23,0x38,0x01,0x1F,0x5A,0x31};

uint32_t TI64Value::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_values = false;
  bool isset_nulls = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->values.clear();
            uint32_t _size53;
            ::apache::thrift::protocol::TType _etype56;
            xfer += iprot->readListBegin(_etype56, _size53);
            this->values.resize(_size53);
            uint32_t _i57;
            for (_i57 = 0; _i57 < _size53; ++_i57)
            {
              xfer += iprot->readI64(this->values[_i57]);
            }
            xfer += iprot->readListEnd();
          }
          isset_values = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->nulls);
          isset_nulls = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_values)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_nulls)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TI64Value::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TI64Value");

  xfer += oprot->writeFieldBegin("values", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->values.size()));
    std::vector<int64_t> ::const_iterator _iter58;
    for (_iter58 = this->values.begin(); _iter58 != this->values.end(); ++_iter58)
    {
      xfer += oprot->writeI64((*_iter58));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nulls", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->nulls);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TI64Value &a, TI64Value &b) {
  using ::std::swap;
  swap(a.values, b.values);
  swap(a.nulls, b.nulls);
}

const char* TDoubleValue::ascii_fingerprint = "8FF1C050A8D7FD247AEB23CD71539C09";
const uint8_t TDoubleValue::binary_fingerprint[16] = {0x8F,0xF1,0xC0,0x50,0xA8,0xD7,0xFD,0x24,0x7A,0xEB,0x23,0xCD,0x71,0x53,0x9C,0x09};

uint32_t TDoubleValue::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_values = false;
  bool isset_nulls = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->values.clear();
            uint32_t _size59;
            ::apache::thrift::protocol::TType _etype62;
            xfer += iprot->readListBegin(_etype62, _size59);
            this->values.resize(_size59);
            uint32_t _i63;
            for (_i63 = 0; _i63 < _size59; ++_i63)
            {
              xfer += iprot->readDouble(this->values[_i63]);
            }
            xfer += iprot->readListEnd();
          }
          isset_values = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->nulls);
          isset_nulls = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_values)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_nulls)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TDoubleValue::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TDoubleValue");

  xfer += oprot->writeFieldBegin("values", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->values.size()));
    std::vector<double> ::const_iterator _iter64;
    for (_iter64 = this->values.begin(); _iter64 != this->values.end(); ++_iter64)
    {
      xfer += oprot->writeDouble((*_iter64));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nulls", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->nulls);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDoubleValue &a, TDoubleValue &b) {
  using ::std::swap;
  swap(a.values, b.values);
  swap(a.nulls, b.nulls);
}

const char* TStringValue::ascii_fingerprint = "BE556BF7091B2DABBA1863D5E458B15F";
const uint8_t TStringValue::binary_fingerprint[16] = {0xBE,0x55,0x6B,0xF7,0x09,0x1B,0x2D,0xAB,0xBA,0x18,0x63,0xD5,0xE4,0x58,0xB1,0x5F};

uint32_t TStringValue::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_values = false;
  bool isset_nulls = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->values.clear();
            uint32_t _size65;
            ::apache::thrift::protocol::TType _etype68;
            xfer += iprot->readListBegin(_etype68, _size65);
            this->values.resize(_size65);
            uint32_t _i69;
            for (_i69 = 0; _i69 < _size65; ++_i69)
            {
              xfer += iprot->readString(this->values[_i69]);
            }
            xfer += iprot->readListEnd();
          }
          isset_values = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->nulls);
          isset_nulls = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_values)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_nulls)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TStringValue::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TStringValue");

  xfer += oprot->writeFieldBegin("values", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->values.size()));
    std::vector<std::string> ::const_iterator _iter70;
    for (_iter70 = this->values.begin(); _iter70 != this->values.end(); ++_iter70)
    {
      xfer += oprot->writeString((*_iter70));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nulls", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->nulls);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TStringValue &a, TStringValue &b) {
  using ::std::swap;
  swap(a.values, b.values);
  swap(a.nulls, b.nulls);
}

const char* TBinaryValue::ascii_fingerprint = "BE556BF7091B2DABBA1863D5E458B15F";
const uint8_t TBinaryValue::binary_fingerprint[16] = {0xBE,0x55,0x6B,0xF7,0x09,0x1B,0x2D,0xAB,0xBA,0x18,0x63,0xD5,0xE4,0x58,0xB1,0x5F};

uint32_t TBinaryValue::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_values = false;
  bool isset_nulls = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->values.clear();
            uint32_t _size71;
            ::apache::thrift::protocol::TType _etype74;
            xfer += iprot->readListBegin(_etype74, _size71);
            this->values.resize(_size71);
            uint32_t _i75;
            for (_i75 = 0; _i75 < _size71; ++_i75)
            {
              xfer += iprot->readBinary(this->values[_i75]);
            }
            xfer += iprot->readListEnd();
          }
          isset_values = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->nulls);
          isset_nulls = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_values)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_nulls)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TBinaryValue::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TBinaryValue");

  xfer += oprot->writeFieldBegin("values", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->values.size()));
    std::vector<std::string> ::const_iterator _iter76;
    for (_iter76 = this->values.begin(); _iter76 != this->values.end(); ++_iter76)
    {
      xfer += oprot->writeBinary((*_iter76));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nulls", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->nulls);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TBinaryValue &a, TBinaryValue &b) {
  using ::std::swap;
  swap(a.values, b.values);
  swap(a.nulls, b.nulls);
}

const char* TColumnValue::ascii_fingerprint = "E6ADD10B4CDDE61A19E8878CC7039A17";
const uint8_t TColumnValue::binary_fingerprint[16] = {0xE6,0xAD,0xD1,0x0B,0x4C,0xDD,0xE6,0x1A,0x19,0xE8,0x87,0x8C,0xC7,0x03,0x9A,0x17};

uint32_t TColumnValue::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->boolVal.read(iprot);
          this->__isset.boolVal = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->byteVal.read(iprot);
          this->__isset.byteVal = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->i16Val.read(iprot);
          this->__isset.i16Val = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->i32Val.read(iprot);
          this->__isset.i32Val = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->i64Val.read(iprot);
          this->__isset.i64Val = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->doubleVal.read(iprot);
          this->__isset.doubleVal = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->stringVal.read(iprot);
          this->__isset.stringVal = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->binaryVal.read(iprot);
          this->__isset.binaryVal = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TColumnValue::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TColumnValue");

  xfer += oprot->writeFieldBegin("boolVal", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->boolVal.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("byteVal", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->byteVal.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("i16Val", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->i16Val.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("i32Val", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->i32Val.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("i64Val", ::apache::thrift::protocol::T_STRUCT, 5);
  xfer += this->i64Val.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("doubleVal", ::apache::thrift::protocol::T_STRUCT, 6);
  xfer += this->doubleVal.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("stringVal", ::apache::thrift::protocol::T_STRUCT, 7);
  xfer += this->stringVal.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("binaryVal", ::apache::thrift::protocol::T_STRUCT, 8);
  xfer += this->binaryVal.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TColumnValue &a, TColumnValue &b) {
  using ::std::swap;
  swap(a.boolVal, b.boolVal);
  swap(a.byteVal, b.byteVal);
  swap(a.i16Val, b.i16Val);
  swap(a.i32Val, b.i32Val);
  swap(a.i64Val, b.i64Val);
  swap(a.doubleVal, b.doubleVal);
  swap(a.stringVal, b.stringVal);
  swap(a.binaryVal, b.binaryVal);
  swap(a.__isset, b.__isset);
}

const char* TRowSet::ascii_fingerprint = "E1067378CC0F0ABAD05696C7DD3A1C7B";
const uint8_t TRowSet::binary_fingerprint[16] = {0xE1,0x06,0x73,0x78,0xCC,0x0F,0x0A,0xBA,0xD0,0x56,0x96,0xC7,0xDD,0x3A,0x1C,0x7B};

uint32_t TRowSet::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_startRowOffset = false;
  bool isset_colVals = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->startRowOffset);
          isset_startRowOffset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->colVals.clear();
            uint32_t _size77;
            ::apache::thrift::protocol::TType _etype80;
            xfer += iprot->readListBegin(_etype80, _size77);
            this->colVals.resize(_size77);
            uint32_t _i81;
            for (_i81 = 0; _i81 < _size77; ++_i81)
            {
              xfer += this->colVals[_i81].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_colVals = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_startRowOffset)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_colVals)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TRowSet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TRowSet");

  xfer += oprot->writeFieldBegin("startRowOffset", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->startRowOffset);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("colVals", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->colVals.size()));
    std::vector<TColumnValue> ::const_iterator _iter82;
    for (_iter82 = this->colVals.begin(); _iter82 != this->colVals.end(); ++_iter82)
    {
      xfer += (*_iter82).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TRowSet &a, TRowSet &b) {
  using ::std::swap;
  swap(a.startRowOffset, b.startRowOffset);
  swap(a.colVals, b.colVals);
}

const char* TStatus::ascii_fingerprint = "D5DEF49634A59C615C1B3A6F7D0DADB5";
const uint8_t TStatus::binary_fingerprint[16] = {0xD5,0xDE,0xF4,0x96,0x34,0xA5,0x9C,0x61,0x5C,0x1B,0x3A,0x6F,0x7D,0x0D,0xAD,0xB5};

uint32_t TStatus::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_statusCode = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast83;
          xfer += iprot->readI32(ecast83);
          this->statusCode = (TStatusCode::type)ecast83;
          isset_statusCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->infoMessages.clear();
            uint32_t _size84;
            ::apache::thrift::protocol::TType _etype87;
            xfer += iprot->readListBegin(_etype87, _size84);
            this->infoMessages.resize(_size84);
            uint32_t _i88;
            for (_i88 = 0; _i88 < _size84; ++_i88)
            {
              xfer += iprot->readString(this->infoMessages[_i88]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.infoMessages = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sqlState);
          this->__isset.sqlState = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->errorCode);
          this->__isset.errorCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->errorMessage);
          this->__isset.errorMessage = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_statusCode)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TStatus::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TStatus");

  xfer += oprot->writeFieldBegin("statusCode", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->statusCode);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.infoMessages) {
    xfer += oprot->writeFieldBegin("infoMessages", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->infoMessages.size()));
      std::vector<std::string> ::const_iterator _iter89;
      for (_iter89 = this->infoMessages.begin(); _iter89 != this->infoMessages.end(); ++_iter89)
      {
        xfer += oprot->writeString((*_iter89));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.sqlState) {
    xfer += oprot->writeFieldBegin("sqlState", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->sqlState);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.errorCode) {
    xfer += oprot->writeFieldBegin("errorCode", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->errorCode);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.errorMessage) {
    xfer += oprot->writeFieldBegin("errorMessage", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->errorMessage);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TStatus &a, TStatus &b) {
  using ::std::swap;
  swap(a.statusCode, b.statusCode);
  swap(a.infoMessages, b.infoMessages);
  swap(a.sqlState, b.sqlState);
  swap(a.errorCode, b.errorCode);
  swap(a.errorMessage, b.errorMessage);
  swap(a.__isset, b.__isset);
}

const char* THandleIdentifier::ascii_fingerprint = "07A9615F837F7D0A952B595DD3020972";
const uint8_t THandleIdentifier::binary_fingerprint[16] = {0x07,0xA9,0x61,0x5F,0x83,0x7F,0x7D,0x0A,0x95,0x2B,0x59,0x5D,0xD3,0x02,0x09,0x72};

uint32_t THandleIdentifier::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_guid = false;
  bool isset_secret = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->guid);
          isset_guid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->secret);
          isset_secret = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_guid)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_secret)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t THandleIdentifier::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("THandleIdentifier");

  xfer += oprot->writeFieldBegin("guid", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->guid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("secret", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->secret);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(THandleIdentifier &a, THandleIdentifier &b) {
  using ::std::swap;
  swap(a.guid, b.guid);
  swap(a.secret, b.secret);
}

const char* TSessionHandle::ascii_fingerprint = "A756D3DBE614FB13F70BF7F7B6EB3D73";
const uint8_t TSessionHandle::binary_fingerprint[16] = {0xA7,0x56,0xD3,0xDB,0xE6,0x14,0xFB,0x13,0xF7,0x0B,0xF7,0xF7,0xB6,0xEB,0x3D,0x73};

uint32_t TSessionHandle::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionId = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sessionId.read(iprot);
          isset_sessionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSessionHandle::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TSessionHandle");

  xfer += oprot->writeFieldBegin("sessionId", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->sessionId.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSessionHandle &a, TSessionHandle &b) {
  using ::std::swap;
  swap(a.sessionId, b.sessionId);
}

const char* TOperationHandle::ascii_fingerprint = "29FD80F4F96804A30FCC59C23D2E5349";
const uint8_t TOperationHandle::binary_fingerprint[16] = {0x29,0xFD,0x80,0xF4,0xF9,0x68,0x04,0xA3,0x0F,0xCC,0x59,0xC2,0x3D,0x2E,0x53,0x49};

uint32_t TOperationHandle::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_operationId = false;
  bool isset_operationType = false;
  bool isset_hasResultSet = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->operationId.read(iprot);
          isset_operationId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast90;
          xfer += iprot->readI32(ecast90);
          this->operationType = (TOperationType::type)ecast90;
          isset_operationType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->hasResultSet);
          isset_hasResultSet = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->modifiedRowCount);
          this->__isset.modifiedRowCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_operationId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_operationType)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_hasResultSet)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TOperationHandle::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TOperationHandle");

  xfer += oprot->writeFieldBegin("operationId", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->operationId.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("operationType", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->operationType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hasResultSet", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->hasResultSet);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.modifiedRowCount) {
    xfer += oprot->writeFieldBegin("modifiedRowCount", ::apache::thrift::protocol::T_DOUBLE, 4);
    xfer += oprot->writeDouble(this->modifiedRowCount);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TOperationHandle &a, TOperationHandle &b) {
  using ::std::swap;
  swap(a.operationId, b.operationId);
  swap(a.operationType, b.operationType);
  swap(a.hasResultSet, b.hasResultSet);
  swap(a.modifiedRowCount, b.modifiedRowCount);
  swap(a.__isset, b.__isset);
}

const char* TOpenSessionReq::ascii_fingerprint = "C8FD0F306A16C16BDA7B57F58BFAE5B2";
const uint8_t TOpenSessionReq::binary_fingerprint[16] = {0xC8,0xFD,0x0F,0x30,0x6A,0x16,0xC1,0x6B,0xDA,0x7B,0x57,0xF5,0x8B,0xFA,0xE5,0xB2};

uint32_t TOpenSessionReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_client_protocol = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast91;
          xfer += iprot->readI32(ecast91);
          this->client_protocol = (TProtocolVersion::type)ecast91;
          isset_client_protocol = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->username);
          this->__isset.username = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->password);
          this->__isset.password = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->configuration.clear();
            uint32_t _size92;
            ::apache::thrift::protocol::TType _ktype93;
            ::apache::thrift::protocol::TType _vtype94;
            xfer += iprot->readMapBegin(_ktype93, _vtype94, _size92);
            uint32_t _i96;
            for (_i96 = 0; _i96 < _size92; ++_i96)
            {
              std::string _key97;
              xfer += iprot->readString(_key97);
              std::string& _val98 = this->configuration[_key97];
              xfer += iprot->readString(_val98);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.configuration = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_client_protocol)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TOpenSessionReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TOpenSessionReq");

  xfer += oprot->writeFieldBegin("client_protocol", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->client_protocol);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.username) {
    xfer += oprot->writeFieldBegin("username", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->username);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.password) {
    xfer += oprot->writeFieldBegin("password", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->password);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.configuration) {
    xfer += oprot->writeFieldBegin("configuration", ::apache::thrift::protocol::T_MAP, 4);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->configuration.size()));
      std::map<std::string, std::string> ::const_iterator _iter99;
      for (_iter99 = this->configuration.begin(); _iter99 != this->configuration.end(); ++_iter99)
      {
        xfer += oprot->writeString(_iter99->first);
        xfer += oprot->writeString(_iter99->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TOpenSessionReq &a, TOpenSessionReq &b) {
  using ::std::swap;
  swap(a.client_protocol, b.client_protocol);
  swap(a.username, b.username);
  swap(a.password, b.password);
  swap(a.configuration, b.configuration);
  swap(a.__isset, b.__isset);
}

const char* TOpenSessionResp::ascii_fingerprint = "CFE7D7F4E9EC671F2518ED74FEE9F163";
const uint8_t TOpenSessionResp::binary_fingerprint[16] = {0xCF,0xE7,0xD7,0xF4,0xE9,0xEC,0x67,0x1F,0x25,0x18,0xED,0x74,0xFE,0xE9,0xF1,0x63};

uint32_t TOpenSessionResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;
  bool isset_serverProtocolVersion = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast100;
          xfer += iprot->readI32(ecast100);
          this->serverProtocolVersion = (TProtocolVersion::type)ecast100;
          isset_serverProtocolVersion = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sessionHandle.read(iprot);
          this->__isset.sessionHandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->configuration.clear();
            uint32_t _size101;
            ::apache::thrift::protocol::TType _ktype102;
            ::apache::thrift::protocol::TType _vtype103;
            xfer += iprot->readMapBegin(_ktype102, _vtype103, _size101);
            uint32_t _i105;
            for (_i105 = 0; _i105 < _size101; ++_i105)
            {
              std::string _key106;
              xfer += iprot->readString(_key106);
              std::string& _val107 = this->configuration[_key106];
              xfer += iprot->readString(_val107);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.configuration = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_serverProtocolVersion)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TOpenSessionResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TOpenSessionResp");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("serverProtocolVersion", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->serverProtocolVersion);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.sessionHandle) {
    xfer += oprot->writeFieldBegin("sessionHandle", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->sessionHandle.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.configuration) {
    xfer += oprot->writeFieldBegin("configuration", ::apache::thrift::protocol::T_MAP, 4);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->configuration.size()));
      std::map<std::string, std::string> ::const_iterator _iter108;
      for (_iter108 = this->configuration.begin(); _iter108 != this->configuration.end(); ++_iter108)
      {
        xfer += oprot->writeString(_iter108->first);
        xfer += oprot->writeString(_iter108->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TOpenSessionResp &a, TOpenSessionResp &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.serverProtocolVersion, b.serverProtocolVersion);
  swap(a.sessionHandle, b.sessionHandle);
  swap(a.configuration, b.configuration);
  swap(a.__isset, b.__isset);
}

const char* TCloseSessionReq::ascii_fingerprint = "82377107F8BD0526960537D5A112E6EF";
const uint8_t TCloseSessionReq::binary_fingerprint[16] = {0x82,0x37,0x71,0x07,0xF8,0xBD,0x05,0x26,0x96,0x05,0x37,0xD5,0xA1,0x12,0xE6,0xEF};

uint32_t TCloseSessionReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionHandle = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sessionHandle.read(iprot);
          isset_sessionHandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionHandle)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TCloseSessionReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TCloseSessionReq");

  xfer += oprot->writeFieldBegin("sessionHandle", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->sessionHandle.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TCloseSessionReq &a, TCloseSessionReq &b) {
  using ::std::swap;
  swap(a.sessionHandle, b.sessionHandle);
}

const char* TCloseSessionResp::ascii_fingerprint = "7142E89F09DC7C5F6FA916C7393F46C2";
const uint8_t TCloseSessionResp::binary_fingerprint[16] = {0x71,0x42,0xE8,0x9F,0x09,0xDC,0x7C,0x5F,0x6F,0xA9,0x16,0xC7,0x39,0x3F,0x46,0xC2};

uint32_t TCloseSessionResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TCloseSessionResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TCloseSessionResp");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TCloseSessionResp &a, TCloseSessionResp &b) {
  using ::std::swap;
  swap(a.status, b.status);
}

const char* TGetInfoValue::ascii_fingerprint = "057FED11279FD7248CFE73EE82ED579E";
const uint8_t TGetInfoValue::binary_fingerprint[16] = {0x05,0x7F,0xED,0x11,0x27,0x9F,0xD7,0x24,0x8C,0xFE,0x73,0xEE,0x82,0xED,0x57,0x9E};

uint32_t TGetInfoValue::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->stringValue);
          this->__isset.stringValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->smallIntValue);
          this->__isset.smallIntValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->integerBitmask);
          this->__isset.integerBitmask = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->integerFlag);
          this->__isset.integerFlag = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->binaryValue);
          this->__isset.binaryValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lenValue);
          this->__isset.lenValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TGetInfoValue::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TGetInfoValue");

  xfer += oprot->writeFieldBegin("stringValue", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->stringValue);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("smallIntValue", ::apache::thrift::protocol::T_I16, 2);
  xfer += oprot->writeI16(this->smallIntValue);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("integerBitmask", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->integerBitmask);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("integerFlag", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->integerFlag);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("binaryValue", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->binaryValue);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lenValue", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->lenValue);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TGetInfoValue &a, TGetInfoValue &b) {
  using ::std::swap;
  swap(a.stringValue, b.stringValue);
  swap(a.smallIntValue, b.smallIntValue);
  swap(a.integerBitmask, b.integerBitmask);
  swap(a.integerFlag, b.integerFlag);
  swap(a.binaryValue, b.binaryValue);
  swap(a.lenValue, b.lenValue);
  swap(a.__isset, b.__isset);
}

const char* TGetInfoReq::ascii_fingerprint = "95675B1A0BADE5F7EDE323809DB679B2";
const uint8_t TGetInfoReq::binary_fingerprint[16] = {0x95,0x67,0x5B,0x1A,0x0B,0xAD,0xE5,0xF7,0xED,0xE3,0x23,0x80,0x9D,0xB6,0x79,0xB2};

uint32_t TGetInfoReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionHandle = false;
  bool isset_infoType = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sessionHandle.read(iprot);
          isset_sessionHandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast109;
          xfer += iprot->readI32(ecast109);
          this->infoType = (TGetInfoType::type)ecast109;
          isset_infoType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionHandle)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_infoType)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TGetInfoReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TGetInfoReq");

  xfer += oprot->writeFieldBegin("sessionHandle", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->sessionHandle.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("infoType", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->infoType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TGetInfoReq &a, TGetInfoReq &b) {
  using ::std::swap;
  swap(a.sessionHandle, b.sessionHandle);
  swap(a.infoType, b.infoType);
}

const char* TGetInfoResp::ascii_fingerprint = "72AFA10A82728B51FDE91092012868DE";
const uint8_t TGetInfoResp::binary_fingerprint[16] = {0x72,0xAF,0xA1,0x0A,0x82,0x72,0x8B,0x51,0xFD,0xE9,0x10,0x92,0x01,0x28,0x68,0xDE};

uint32_t TGetInfoResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;
  bool isset_infoValue = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->infoValue.read(iprot);
          isset_infoValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_infoValue)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TGetInfoResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TGetInfoResp");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("infoValue", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->infoValue.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TGetInfoResp &a, TGetInfoResp &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.infoValue, b.infoValue);
}

const char* TExecuteStatementReq::ascii_fingerprint = "4CDA19909D21B7D9907F85E3387EAB27";
const uint8_t TExecuteStatementReq::binary_fingerprint[16] = {0x4C,0xDA,0x19,0x90,0x9D,0x21,0xB7,0xD9,0x90,0x7F,0x85,0xE3,0x38,0x7E,0xAB,0x27};

uint32_t TExecuteStatementReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionHandle = false;
  bool isset_statement = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sessionHandle.read(iprot);
          isset_sessionHandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->statement);
          isset_statement = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->confOverlay.clear();
            uint32_t _size110;
            ::apache::thrift::protocol::TType _ktype111;
            ::apache::thrift::protocol::TType _vtype112;
            xfer += iprot->readMapBegin(_ktype111, _vtype112, _size110);
            uint32_t _i114;
            for (_i114 = 0; _i114 < _size110; ++_i114)
            {
              std::string _key115;
              xfer += iprot->readString(_key115);
              std::string& _val116 = this->confOverlay[_key115];
              xfer += iprot->readString(_val116);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.confOverlay = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionHandle)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_statement)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TExecuteStatementReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TExecuteStatementReq");

  xfer += oprot->writeFieldBegin("sessionHandle", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->sessionHandle.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("statement", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->statement);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.confOverlay) {
    xfer += oprot->writeFieldBegin("confOverlay", ::apache::thrift::protocol::T_MAP, 3);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->confOverlay.size()));
      std::map<std::string, std::string> ::const_iterator _iter117;
      for (_iter117 = this->confOverlay.begin(); _iter117 != this->confOverlay.end(); ++_iter117)
      {
        xfer += oprot->writeString(_iter117->first);
        xfer += oprot->writeString(_iter117->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TExecuteStatementReq &a, TExecuteStatementReq &b) {
  using ::std::swap;
  swap(a.sessionHandle, b.sessionHandle);
  swap(a.statement, b.statement);
  swap(a.confOverlay, b.confOverlay);
  swap(a.__isset, b.__isset);
}

const char* TExecuteStatementResp::ascii_fingerprint = "02A075A0FF88D3A172916D8F23C7B286";
const uint8_t TExecuteStatementResp::binary_fingerprint[16] = {0x02,0xA0,0x75,0xA0,0xFF,0x88,0xD3,0xA1,0x72,0x91,0x6D,0x8F,0x23,0xC7,0xB2,0x86};

uint32_t TExecuteStatementResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->operationHandle.read(iprot);
          this->__isset.operationHandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TExecuteStatementResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TExecuteStatementResp");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.operationHandle) {
    xfer += oprot->writeFieldBegin("operationHandle", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->operationHandle.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TExecuteStatementResp &a, TExecuteStatementResp &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.operationHandle, b.operationHandle);
  swap(a.__isset, b.__isset);
}

const char* TGetTypeInfoReq::ascii_fingerprint = "82377107F8BD0526960537D5A112E6EF";
const uint8_t TGetTypeInfoReq::binary_fingerprint[16] = {0x82,0x37,0x71,0x07,0xF8,0xBD,0x05,0x26,0x96,0x05,0x37,0xD5,0xA1,0x12,0xE6,0xEF};

uint32_t TGetTypeInfoReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionHandle = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sessionHandle.read(iprot);
          isset_sessionHandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionHandle)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TGetTypeInfoReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TGetTypeInfoReq");

  xfer += oprot->writeFieldBegin("sessionHandle", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->sessionHandle.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TGetTypeInfoReq &a, TGetTypeInfoReq &b) {
  using ::std::swap;
  swap(a.sessionHandle, b.sessionHandle);
}

const char* TGetTypeInfoResp::ascii_fingerprint = "02A075A0FF88D3A172916D8F23C7B286";
const uint8_t TGetTypeInfoResp::binary_fingerprint[16] = {0x02,0xA0,0x75,0xA0,0xFF,0x88,0xD3,0xA1,0x72,0x91,0x6D,0x8F,0x23,0xC7,0xB2,0x86};

uint32_t TGetTypeInfoResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->operationHandle.read(iprot);
          this->__isset.operationHandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TGetTypeInfoResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TGetTypeInfoResp");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.operationHandle) {
    xfer += oprot->writeFieldBegin("operationHandle", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->operationHandle.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TGetTypeInfoResp &a, TGetTypeInfoResp &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.operationHandle, b.operationHandle);
  swap(a.__isset, b.__isset);
}

const char* TGetCatalogsReq::ascii_fingerprint = "82377107F8BD0526960537D5A112E6EF";
const uint8_t TGetCatalogsReq::binary_fingerprint[16] = {0x82,0x37,0x71,0x07,0xF8,0xBD,0x05,0x26,0x96,0x05,0x37,0xD5,0xA1,0x12,0xE6,0xEF};

uint32_t TGetCatalogsReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionHandle = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sessionHandle.read(iprot);
          isset_sessionHandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionHandle)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TGetCatalogsReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TGetCatalogsReq");

  xfer += oprot->writeFieldBegin("sessionHandle", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->sessionHandle.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TGetCatalogsReq &a, TGetCatalogsReq &b) {
  using ::std::swap;
  swap(a.sessionHandle, b.sessionHandle);
}

const char* TGetCatalogsResp::ascii_fingerprint = "02A075A0FF88D3A172916D8F23C7B286";
const uint8_t TGetCatalogsResp::binary_fingerprint[16] = {0x02,0xA0,0x75,0xA0,0xFF,0x88,0xD3,0xA1,0x72,0x91,0x6D,0x8F,0x23,0xC7,0xB2,0x86};

uint32_t TGetCatalogsResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->operationHandle.read(iprot);
          this->__isset.operationHandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TGetCatalogsResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TGetCatalogsResp");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.operationHandle) {
    xfer += oprot->writeFieldBegin("operationHandle", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->operationHandle.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TGetCatalogsResp &a, TGetCatalogsResp &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.operationHandle, b.operationHandle);
  swap(a.__isset, b.__isset);
}

const char* TGetSchemasReq::ascii_fingerprint = "28A9D12DE8393DD3E73FC1E5AE6E113B";
const uint8_t TGetSchemasReq::binary_fingerprint[16] = {0x28,0xA9,0xD1,0x2D,0xE8,0x39,0x3D,0xD3,0xE7,0x3F,0xC1,0xE5,0xAE,0x6E,0x11,0x3B};

uint32_t TGetSchemasReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionHandle = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sessionHandle.read(iprot);
          isset_sessionHandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catalogName);
          this->__isset.catalogName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->schemaName);
          this->__isset.schemaName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionHandle)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TGetSchemasReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TGetSchemasReq");

  xfer += oprot->writeFieldBegin("sessionHandle", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->sessionHandle.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.catalogName) {
    xfer += oprot->writeFieldBegin("catalogName", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->catalogName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.schemaName) {
    xfer += oprot->writeFieldBegin("schemaName", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->schemaName);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TGetSchemasReq &a, TGetSchemasReq &b) {
  using ::std::swap;
  swap(a.sessionHandle, b.sessionHandle);
  swap(a.catalogName, b.catalogName);
  swap(a.schemaName, b.schemaName);
  swap(a.__isset, b.__isset);
}

const char* TGetSchemasResp::ascii_fingerprint = "02A075A0FF88D3A172916D8F23C7B286";
const uint8_t TGetSchemasResp::binary_fingerprint[16] = {0x02,0xA0,0x75,0xA0,0xFF,0x88,0xD3,0xA1,0x72,0x91,0x6D,0x8F,0x23,0xC7,0xB2,0x86};

uint32_t TGetSchemasResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->operationHandle.read(iprot);
          this->__isset.operationHandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TGetSchemasResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TGetSchemasResp");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.operationHandle) {
    xfer += oprot->writeFieldBegin("operationHandle", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->operationHandle.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TGetSchemasResp &a, TGetSchemasResp &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.operationHandle, b.operationHandle);
  swap(a.__isset, b.__isset);
}

const char* TGetTablesReq::ascii_fingerprint = "C80DFEE06850052F5A445BE81ED763DB";
const uint8_t TGetTablesReq::binary_fingerprint[16] = {0xC8,0x0D,0xFE,0xE0,0x68,0x50,0x05,0x2F,0x5A,0x44,0x5B,0xE8,0x1E,0xD7,0x63,0xDB};

uint32_t TGetTablesReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionHandle = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sessionHandle.read(iprot);
          isset_sessionHandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catalogName);
          this->__isset.catalogName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->schemaName);
          this->__isset.schemaName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          this->__isset.tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->tableTypes.clear();
            uint32_t _size118;
            ::apache::thrift::protocol::TType _etype121;
            xfer += iprot->readListBegin(_etype121, _size118);
            this->tableTypes.resize(_size118);
            uint32_t _i122;
            for (_i122 = 0; _i122 < _size118; ++_i122)
            {
              xfer += iprot->readString(this->tableTypes[_i122]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.tableTypes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionHandle)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TGetTablesReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TGetTablesReq");

  xfer += oprot->writeFieldBegin("sessionHandle", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->sessionHandle.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.catalogName) {
    xfer += oprot->writeFieldBegin("catalogName", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->catalogName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.schemaName) {
    xfer += oprot->writeFieldBegin("schemaName", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->schemaName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tableName) {
    xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->tableName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tableTypes) {
    xfer += oprot->writeFieldBegin("tableTypes", ::apache::thrift::protocol::T_LIST, 5);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->tableTypes.size()));
      std::vector<std::string> ::const_iterator _iter123;
      for (_iter123 = this->tableTypes.begin(); _iter123 != this->tableTypes.end(); ++_iter123)
      {
        xfer += oprot->writeString((*_iter123));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TGetTablesReq &a, TGetTablesReq &b) {
  using ::std::swap;
  swap(a.sessionHandle, b.sessionHandle);
  swap(a.catalogName, b.catalogName);
  swap(a.schemaName, b.schemaName);
  swap(a.tableName, b.tableName);
  swap(a.tableTypes, b.tableTypes);
  swap(a.__isset, b.__isset);
}

const char* TGetTablesResp::ascii_fingerprint = "02A075A0FF88D3A172916D8F23C7B286";
const uint8_t TGetTablesResp::binary_fingerprint[16] = {0x02,0xA0,0x75,0xA0,0xFF,0x88,0xD3,0xA1,0x72,0x91,0x6D,0x8F,0x23,0xC7,0xB2,0x86};

uint32_t TGetTablesResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->operationHandle.read(iprot);
          this->__isset.operationHandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TGetTablesResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TGetTablesResp");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.operationHandle) {
    xfer += oprot->writeFieldBegin("operationHandle", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->operationHandle.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TGetTablesResp &a, TGetTablesResp &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.operationHandle, b.operationHandle);
  swap(a.__isset, b.__isset);
}

const char* TGetTableTypesReq::ascii_fingerprint = "82377107F8BD0526960537D5A112E6EF";
const uint8_t TGetTableTypesReq::binary_fingerprint[16] = {0x82,0x37,0x71,0x07,0xF8,0xBD,0x05,0x26,0x96,0x05,0x37,0xD5,0xA1,0x12,0xE6,0xEF};

uint32_t TGetTableTypesReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionHandle = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sessionHandle.read(iprot);
          isset_sessionHandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionHandle)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TGetTableTypesReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TGetTableTypesReq");

  xfer += oprot->writeFieldBegin("sessionHandle", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->sessionHandle.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TGetTableTypesReq &a, TGetTableTypesReq &b) {
  using ::std::swap;
  swap(a.sessionHandle, b.sessionHandle);
}

const char* TGetTableTypesResp::ascii_fingerprint = "02A075A0FF88D3A172916D8F23C7B286";
const uint8_t TGetTableTypesResp::binary_fingerprint[16] = {0x02,0xA0,0x75,0xA0,0xFF,0x88,0xD3,0xA1,0x72,0x91,0x6D,0x8F,0x23,0xC7,0xB2,0x86};

uint32_t TGetTableTypesResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->operationHandle.read(iprot);
          this->__isset.operationHandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TGetTableTypesResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TGetTableTypesResp");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.operationHandle) {
    xfer += oprot->writeFieldBegin("operationHandle", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->operationHandle.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TGetTableTypesResp &a, TGetTableTypesResp &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.operationHandle, b.operationHandle);
  swap(a.__isset, b.__isset);
}

const char* TGetColumnsReq::ascii_fingerprint = "72D0F28ED33A49B7306DF63EEE956C28";
const uint8_t TGetColumnsReq::binary_fingerprint[16] = {0x72,0xD0,0xF2,0x8E,0xD3,0x3A,0x49,0xB7,0x30,0x6D,0xF6,0x3E,0xEE,0x95,0x6C,0x28};

uint32_t TGetColumnsReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionHandle = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sessionHandle.read(iprot);
          isset_sessionHandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catalogName);
          this->__isset.catalogName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->schemaName);
          this->__isset.schemaName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          this->__isset.tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->columnName);
          this->__isset.columnName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionHandle)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TGetColumnsReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TGetColumnsReq");

  xfer += oprot->writeFieldBegin("sessionHandle", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->sessionHandle.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.catalogName) {
    xfer += oprot->writeFieldBegin("catalogName", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->catalogName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.schemaName) {
    xfer += oprot->writeFieldBegin("schemaName", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->schemaName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tableName) {
    xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->tableName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.columnName) {
    xfer += oprot->writeFieldBegin("columnName", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->columnName);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TGetColumnsReq &a, TGetColumnsReq &b) {
  using ::std::swap;
  swap(a.sessionHandle, b.sessionHandle);
  swap(a.catalogName, b.catalogName);
  swap(a.schemaName, b.schemaName);
  swap(a.tableName, b.tableName);
  swap(a.columnName, b.columnName);
  swap(a.__isset, b.__isset);
}

const char* TGetColumnsResp::ascii_fingerprint = "02A075A0FF88D3A172916D8F23C7B286";
const uint8_t TGetColumnsResp::binary_fingerprint[16] = {0x02,0xA0,0x75,0xA0,0xFF,0x88,0xD3,0xA1,0x72,0x91,0x6D,0x8F,0x23,0xC7,0xB2,0x86};

uint32_t TGetColumnsResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->operationHandle.read(iprot);
          this->__isset.operationHandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TGetColumnsResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TGetColumnsResp");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.operationHandle) {
    xfer += oprot->writeFieldBegin("operationHandle", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->operationHandle.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TGetColumnsResp &a, TGetColumnsResp &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.operationHandle, b.operationHandle);
  swap(a.__isset, b.__isset);
}

const char* TGetFunctionsReq::ascii_fingerprint = "0887E0916ADE4521BF6017B534493138";
const uint8_t TGetFunctionsReq::binary_fingerprint[16] = {0x08,0x87,0xE0,0x91,0x6A,0xDE,0x45,0x21,0xBF,0x60,0x17,0xB5,0x34,0x49,0x31,0x38};

uint32_t TGetFunctionsReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionHandle = false;
  bool isset_functionName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sessionHandle.read(iprot);
          isset_sessionHandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catalogName);
          this->__isset.catalogName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->schemaName);
          this->__isset.schemaName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->functionName);
          isset_functionName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionHandle)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_functionName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TGetFunctionsReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TGetFunctionsReq");

  xfer += oprot->writeFieldBegin("sessionHandle", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->sessionHandle.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.catalogName) {
    xfer += oprot->writeFieldBegin("catalogName", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->catalogName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.schemaName) {
    xfer += oprot->writeFieldBegin("schemaName", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->schemaName);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("functionName", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->functionName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TGetFunctionsReq &a, TGetFunctionsReq &b) {
  using ::std::swap;
  swap(a.sessionHandle, b.sessionHandle);
  swap(a.catalogName, b.catalogName);
  swap(a.schemaName, b.schemaName);
  swap(a.functionName, b.functionName);
  swap(a.__isset, b.__isset);
}

const char* TGetFunctionsResp::ascii_fingerprint = "02A075A0FF88D3A172916D8F23C7B286";
const uint8_t TGetFunctionsResp::binary_fingerprint[16] = {0x02,0xA0,0x75,0xA0,0xFF,0x88,0xD3,0xA1,0x72,0x91,0x6D,0x8F,0x23,0xC7,0xB2,0x86};

uint32_t TGetFunctionsResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->operationHandle.read(iprot);
          this->__isset.operationHandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TGetFunctionsResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TGetFunctionsResp");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.operationHandle) {
    xfer += oprot->writeFieldBegin("operationHandle", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->operationHandle.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TGetFunctionsResp &a, TGetFunctionsResp &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.operationHandle, b.operationHandle);
  swap(a.__isset, b.__isset);
}

const char* TGetOperationStatusReq::ascii_fingerprint = "414FA38522AE6B9CEC1438B56CA1DE5A";
const uint8_t TGetOperationStatusReq::binary_fingerprint[16] = {0x41,0x4F,0xA3,0x85,0x22,0xAE,0x6B,0x9C,0xEC,0x14,0x38,0xB5,0x6C,0xA1,0xDE,0x5A};

uint32_t TGetOperationStatusReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_operationHandle = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->operationHandle.read(iprot);
          isset_operationHandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_operationHandle)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TGetOperationStatusReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TGetOperationStatusReq");

  xfer += oprot->writeFieldBegin("operationHandle", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->operationHandle.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TGetOperationStatusReq &a, TGetOperationStatusReq &b) {
  using ::std::swap;
  swap(a.operationHandle, b.operationHandle);
}

const char* TGetOperationStatusResp::ascii_fingerprint = "4F27EC6715D9B6D702A4842459E6587B";
const uint8_t TGetOperationStatusResp::binary_fingerprint[16] = {0x4F,0x27,0xEC,0x67,0x15,0xD9,0xB6,0xD7,0x02,0xA4,0x84,0x24,0x59,0xE6,0x58,0x7B};

uint32_t TGetOperationStatusResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast124;
          xfer += iprot->readI32(ecast124);
          this->operationState = (TOperationState::type)ecast124;
          this->__isset.operationState = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TGetOperationStatusResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TGetOperationStatusResp");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.operationState) {
    xfer += oprot->writeFieldBegin("operationState", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32((int32_t)this->operationState);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TGetOperationStatusResp &a, TGetOperationStatusResp &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.operationState, b.operationState);
  swap(a.__isset, b.__isset);
}

const char* TCancelOperationReq::ascii_fingerprint = "414FA38522AE6B9CEC1438B56CA1DE5A";
const uint8_t TCancelOperationReq::binary_fingerprint[16] = {0x41,0x4F,0xA3,0x85,0x22,0xAE,0x6B,0x9C,0xEC,0x14,0x38,0xB5,0x6C,0xA1,0xDE,0x5A};

uint32_t TCancelOperationReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_operationHandle = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->operationHandle.read(iprot);
          isset_operationHandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_operationHandle)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TCancelOperationReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TCancelOperationReq");

  xfer += oprot->writeFieldBegin("operationHandle", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->operationHandle.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TCancelOperationReq &a, TCancelOperationReq &b) {
  using ::std::swap;
  swap(a.operationHandle, b.operationHandle);
}

const char* TCancelOperationResp::ascii_fingerprint = "7142E89F09DC7C5F6FA916C7393F46C2";
const uint8_t TCancelOperationResp::binary_fingerprint[16] = {0x71,0x42,0xE8,0x9F,0x09,0xDC,0x7C,0x5F,0x6F,0xA9,0x16,0xC7,0x39,0x3F,0x46,0xC2};

uint32_t TCancelOperationResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TCancelOperationResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TCancelOperationResp");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TCancelOperationResp &a, TCancelOperationResp &b) {
  using ::std::swap;
  swap(a.status, b.status);
}

const char* TCloseOperationReq::ascii_fingerprint = "414FA38522AE6B9CEC1438B56CA1DE5A";
const uint8_t TCloseOperationReq::binary_fingerprint[16] = {0x41,0x4F,0xA3,0x85,0x22,0xAE,0x6B,0x9C,0xEC,0x14,0x38,0xB5,0x6C,0xA1,0xDE,0x5A};

uint32_t TCloseOperationReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_operationHandle = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->operationHandle.read(iprot);
          isset_operationHandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_operationHandle)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TCloseOperationReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TCloseOperationReq");

  xfer += oprot->writeFieldBegin("operationHandle", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->operationHandle.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TCloseOperationReq &a, TCloseOperationReq &b) {
  using ::std::swap;
  swap(a.operationHandle, b.operationHandle);
}

const char* TCloseOperationResp::ascii_fingerprint = "7142E89F09DC7C5F6FA916C7393F46C2";
const uint8_t TCloseOperationResp::binary_fingerprint[16] = {0x71,0x42,0xE8,0x9F,0x09,0xDC,0x7C,0x5F,0x6F,0xA9,0x16,0xC7,0x39,0x3F,0x46,0xC2};

uint32_t TCloseOperationResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TCloseOperationResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TCloseOperationResp");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TCloseOperationResp &a, TCloseOperationResp &b) {
  using ::std::swap;
  swap(a.status, b.status);
}

const char* TGetResultSetMetadataReq::ascii_fingerprint = "414FA38522AE6B9CEC1438B56CA1DE5A";
const uint8_t TGetResultSetMetadataReq::binary_fingerprint[16] = {0x41,0x4F,0xA3,0x85,0x22,0xAE,0x6B,0x9C,0xEC,0x14,0x38,0xB5,0x6C,0xA1,0xDE,0x5A};

uint32_t TGetResultSetMetadataReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_operationHandle = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->operationHandle.read(iprot);
          isset_operationHandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_operationHandle)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TGetResultSetMetadataReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TGetResultSetMetadataReq");

  xfer += oprot->writeFieldBegin("operationHandle", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->operationHandle.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TGetResultSetMetadataReq &a, TGetResultSetMetadataReq &b) {
  using ::std::swap;
  swap(a.operationHandle, b.operationHandle);
}

const char* TGetResultSetMetadataResp::ascii_fingerprint = "8778316D0AFC17584F192162BFF2AEDE";
const uint8_t TGetResultSetMetadataResp::binary_fingerprint[16] = {0x87,0x78,0x31,0x6D,0x0A,0xFC,0x17,0x58,0x4F,0x19,0x21,0x62,0xBF,0xF2,0xAE,0xDE};

uint32_t TGetResultSetMetadataResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->schema.read(iprot);
          this->__isset.schema = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TGetResultSetMetadataResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TGetResultSetMetadataResp");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.schema) {
    xfer += oprot->writeFieldBegin("schema", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->schema.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TGetResultSetMetadataResp &a, TGetResultSetMetadataResp &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.schema, b.schema);
  swap(a.__isset, b.__isset);
}

const char* TFetchResultsReq::ascii_fingerprint = "1B96A8C05BA9DD699FC8CD842240ABDE";
const uint8_t TFetchResultsReq::binary_fingerprint[16] = {0x1B,0x96,0xA8,0xC0,0x5B,0xA9,0xDD,0x69,0x9F,0xC8,0xCD,0x84,0x22,0x40,0xAB,0xDE};

uint32_t TFetchResultsReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_operationHandle = false;
  bool isset_orientation = false;
  bool isset_maxRows = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->operationHandle.read(iprot);
          isset_operationHandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast125;
          xfer += iprot->readI32(ecast125);
          this->orientation = (TFetchOrientation::type)ecast125;
          isset_orientation = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->maxRows);
          isset_maxRows = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_operationHandle)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_orientation)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_maxRows)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TFetchResultsReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TFetchResultsReq");

  xfer += oprot->writeFieldBegin("operationHandle", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->operationHandle.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("orientation", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->orientation);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxRows", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->maxRows);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TFetchResultsReq &a, TFetchResultsReq &b) {
  using ::std::swap;
  swap(a.operationHandle, b.operationHandle);
  swap(a.orientation, b.orientation);
  swap(a.maxRows, b.maxRows);
}

const char* TFetchResultsResp::ascii_fingerprint = "2DCE0738D7D98BD2D93BEC657702B496";
const uint8_t TFetchResultsResp::binary_fingerprint[16] = {0x2D,0xCE,0x07,0x38,0xD7,0xD9,0x8B,0xD2,0xD9,0x3B,0xEC,0x65,0x77,0x02,0xB4,0x96};

uint32_t TFetchResultsResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->hasMoreRows);
          this->__isset.hasMoreRows = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->results.read(iprot);
          this->__isset.results = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TFetchResultsResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TFetchResultsResp");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.hasMoreRows) {
    xfer += oprot->writeFieldBegin("hasMoreRows", ::apache::thrift::protocol::T_BOOL, 2);
    xfer += oprot->writeBool(this->hasMoreRows);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.results) {
    xfer += oprot->writeFieldBegin("results", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->results.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TFetchResultsResp &a, TFetchResultsResp &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.hasMoreRows, b.hasMoreRows);
  swap(a.results, b.results);
  swap(a.__isset, b.__isset);
}

const char* TCompileRes::ascii_fingerprint = "0109DD9AF87F9C16A0392FEEF0301D54";
const uint8_t TCompileRes::binary_fingerprint[16] = {0x01,0x09,0xDD,0x9A,0xF8,0x7F,0x9C,0x16,0xA0,0x39,0x2F,0xEE,0xF0,0x30,0x1D,0x54};

uint32_t TCompileRes::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;
  bool isset_operationHandle = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->operationHandle.read(iprot);
          isset_operationHandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->queryPlan.read(iprot);
          this->__isset.queryPlan = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_operationHandle)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TCompileRes::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TCompileRes");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("operationHandle", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->operationHandle.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.queryPlan) {
    xfer += oprot->writeFieldBegin("queryPlan", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->queryPlan.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TCompileRes &a, TCompileRes &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.operationHandle, b.operationHandle);
  swap(a.queryPlan, b.queryPlan);
  swap(a.__isset, b.__isset);
}

const char* TRunReq::ascii_fingerprint = "A9814AAA9B38DC20E9E64AA8FF529EC3";
const uint8_t TRunReq::binary_fingerprint[16] = {0xA9,0x81,0x4A,0xAA,0x9B,0x38,0xDC,0x20,0xE9,0xE6,0x4A,0xA8,0xFF,0x52,0x9E,0xC3};

uint32_t TRunReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionHandle = false;
  bool isset_operationHandle = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sessionHandle.read(iprot);
          isset_sessionHandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->operationHandle.read(iprot);
          isset_operationHandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionHandle)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_operationHandle)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TRunReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TRunReq");

  xfer += oprot->writeFieldBegin("sessionHandle", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->sessionHandle.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("operationHandle", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->operationHandle.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TRunReq &a, TRunReq &b) {
  using ::std::swap;
  swap(a.sessionHandle, b.sessionHandle);
  swap(a.operationHandle, b.operationHandle);
}

const char* TSessionInfo::ascii_fingerprint = "74FED9F7B6BB8BDB5BB02BDC66895350";
const uint8_t TSessionInfo::binary_fingerprint[16] = {0x74,0xFE,0xD9,0xF7,0xB6,0xBB,0x8B,0xDB,0x5B,0xB0,0x2B,0xDC,0x66,0x89,0x53,0x50};

uint32_t TSessionInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionHandle = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sessionHandle.read(iprot);
          isset_sessionHandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->startTime);
          this->__isset.startTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionHandle)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSessionInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TSessionInfo");

  xfer += oprot->writeFieldBegin("sessionHandle", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->sessionHandle.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.startTime) {
    xfer += oprot->writeFieldBegin("startTime", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->startTime);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSessionInfo &a, TSessionInfo &b) {
  using ::std::swap;
  swap(a.sessionHandle, b.sessionHandle);
  swap(a.startTime, b.startTime);
  swap(a.__isset, b.__isset);
}

const char* TSessionsRes::ascii_fingerprint = "7C5AECF7734E038F4A75EB753013C743";
const uint8_t TSessionsRes::binary_fingerprint[16] = {0x7C,0x5A,0xEC,0xF7,0x73,0x4E,0x03,0x8F,0x4A,0x75,0xEB,0x75,0x30,0x13,0xC7,0x43};

uint32_t TSessionsRes::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->sessions.clear();
            uint32_t _size126;
            ::apache::thrift::protocol::TType _etype129;
            xfer += iprot->readListBegin(_etype129, _size126);
            this->sessions.resize(_size126);
            uint32_t _i130;
            for (_i130 = 0; _i130 < _size126; ++_i130)
            {
              xfer += this->sessions[_i130].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.sessions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TSessionsRes::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TSessionsRes");

  if (this->__isset.sessions) {
    xfer += oprot->writeFieldBegin("sessions", ::apache::thrift::protocol::T_LIST, 1);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->sessions.size()));
      std::vector<TSessionInfo> ::const_iterator _iter131;
      for (_iter131 = this->sessions.begin(); _iter131 != this->sessions.end(); ++_iter131)
      {
        xfer += (*_iter131).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSessionsRes &a, TSessionsRes &b) {
  using ::std::swap;
  swap(a.sessions, b.sessions);
  swap(a.__isset, b.__isset);
}

const char* TOperationInfo::ascii_fingerprint = "6288B3B16C58123857C2AD058C66AECD";
const uint8_t TOperationInfo::binary_fingerprint[16] = {0x62,0x88,0xB3,0xB1,0x6C,0x58,0x12,0x38,0x57,0xC2,0xAD,0x05,0x8C,0x66,0xAE,0xCD};

uint32_t TOperationInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;
  bool isset_operationHandle = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast132;
          xfer += iprot->readI32(ecast132);
          this->status = (TOperationState::type)ecast132;
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->operationHandle.read(iprot);
          isset_operationHandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->query);
          this->__isset.query = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->startTime);
          this->__isset.startTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_operationHandle)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TOperationInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TOperationInfo");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("operationHandle", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->operationHandle.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.query) {
    xfer += oprot->writeFieldBegin("query", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->query);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.startTime) {
    xfer += oprot->writeFieldBegin("startTime", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->startTime);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TOperationInfo &a, TOperationInfo &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.operationHandle, b.operationHandle);
  swap(a.query, b.query);
  swap(a.startTime, b.startTime);
  swap(a.__isset, b.__isset);
}

const char* TOperationsRes::ascii_fingerprint = "CEFE855D4837B713040CF5BE8F9B9378";
const uint8_t TOperationsRes::binary_fingerprint[16] = {0xCE,0xFE,0x85,0x5D,0x48,0x37,0xB7,0x13,0x04,0x0C,0xF5,0xBE,0x8F,0x9B,0x93,0x78};

uint32_t TOperationsRes::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->operations.clear();
            uint32_t _size133;
            ::apache::thrift::protocol::TType _etype136;
            xfer += iprot->readListBegin(_etype136, _size133);
            this->operations.resize(_size133);
            uint32_t _i137;
            for (_i137 = 0; _i137 < _size133; ++_i137)
            {
              xfer += this->operations[_i137].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.operations = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TOperationsRes::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TOperationsRes");

  if (this->__isset.operations) {
    xfer += oprot->writeFieldBegin("operations", ::apache::thrift::protocol::T_LIST, 1);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->operations.size()));
      std::vector<TOperationInfo> ::const_iterator _iter138;
      for (_iter138 = this->operations.begin(); _iter138 != this->operations.end(); ++_iter138)
      {
        xfer += (*_iter138).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TOperationsRes &a, TOperationsRes &b) {
  using ::std::swap;
  swap(a.operations, b.operations);
  swap(a.__isset, b.__isset);
}

}}}}} // namespace
